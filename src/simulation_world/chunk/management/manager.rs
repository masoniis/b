use bevy_ecs::prelude::*;
use glam::IVec3;
use std::collections::{HashMap, HashSet};

/// Resource that tracks the state of chunks in the world.
#[derive(Resource, Default, Debug)]
pub struct ChunkManager {
    /// Map of coordinates for chunks that are fully loaded and have an entity spawned.
    ///
    /// Key: IVec3 chunk coordinate (e.g., (0, 0, 0), (1, 0, 0))
    /// Value: Entity ID that contains the `Chunk` component and `TransformComponent`.
    pub loaded_chunks: HashMap<IVec3, Entity>,

    /// Set of coordinates for chunks that are currently being generated by an async task.
    /// This prevents requesting the same chunk multiple times if the player moves quickly.
    pub loading_chunks: HashSet<IVec3>,
}

impl ChunkManager {
    /// Checks if a chunk is either fully loaded or currently being generated.
    pub fn is_chunk_present_or_loading(&self, coord: IVec3) -> bool {
        self.loaded_chunks.contains_key(&coord) || self.loading_chunks.contains(&coord)
    }

    /// Call this when you spawn an async task to generate a chunk.
    pub fn mark_as_loading(&mut self, coord: IVec3) {
        self.loading_chunks.insert(coord);
    }

    /// Call this inside the loading task's callback *after* the chunk entity is spawned.
    pub fn mark_as_loaded(&mut self, coord: IVec3, entity: Entity) {
        self.loading_chunks.remove(&coord); // It's no longer loading
        self.loaded_chunks.insert(coord, entity); // It's now loaded
    }

    /// Call this when you despawn a chunk entity.
    pub fn mark_as_unloaded(&mut self, coord: IVec3) {
        // Remove from both in case it was somehow marked as loading
        // while also being considered loaded (shouldn't happen ideally).
        self.loading_chunks.remove(&coord);
        self.loaded_chunks.remove(&coord);
    }
}
