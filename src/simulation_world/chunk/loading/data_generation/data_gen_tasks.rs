use crate::prelude::*;
use crate::simulation_world::camera::ActiveCamera;
use crate::simulation_world::chunk::manage_mesh_state::chunk_is_in_mesh_radius;
use crate::simulation_world::chunk::mesh_gen_tasks::CheckForMeshing;
use crate::simulation_world::chunk::{ChunkBlocksComponent, ChunkState, WantsMeshing};
use crate::simulation_world::{
    biome::BiomeRegistryResource,
    block::BlockRegistryResource,
    chunk::{ChunkCoord, ChunkLoadingManager},
    generation::{
        core::{ActiveBiomeGenerator, GeneratedChunkComponentBundle},
        ActiveTerrainGenerator, ClimateNoiseGenerator,
    },
};
use bevy_ecs::prelude::*;
use crossbeam::channel::{unbounded, Receiver, TryRecvError};

/// Marks a chunk loading task in the simulation world that returns nothing.
#[derive(Component)]
pub struct ChunkGenerationTaskComponent {
    pub receiver: Receiver<GeneratedChunkComponentBundle>,
}

/// A signal marking that chunks should be checked to potentially clear their data. Since
/// a chunk needs to hold its block data until all neighboring chunks are meshed, using
/// this signal enables deallocating of the memory after neighbors have used it.
#[derive(Component)]
pub struct CheckForBlockDataIsNoLongerNeeded;

/// Marks that a chunk needs to have its data generated by the terrain generator.
#[derive(Component)]
pub struct NeedsGenerating;

/// Queries for entities needing generation and starts a limited number per frame.
#[instrument(skip_all)]
pub fn start_pending_generation_tasks_system(
    // Input
    mut pending_chunks_query: Query<
        (Entity, &NeedsGenerating, &ChunkCoord),
        Without<ChunkGenerationTaskComponent>,
    >,

    // Output/Resources
    mut commands: Commands,
    mut chunk_manager: ResMut<ChunkLoadingManager>,
    block_registry: Res<BlockRegistryResource>,
    biome_registry: Res<BiomeRegistryResource>,
    biome_generator: Res<ActiveBiomeGenerator>,
    terrain_generator: Res<ActiveTerrainGenerator>,
    climate_noise: Res<ClimateNoiseGenerator>,
) {
    for (entity, _, coord) in pending_chunks_query.iter_mut() {
        // check for cancellation
        match chunk_manager.get_state(coord.pos) {
            Some(ChunkState::NeedsGenerating(state_entity)) if state_entity == entity => {
                // state is correct, proceed to start generation
            }
            _ => {
                debug!(
                    target : "chunk_loading",
                    "Entity {:?} NeedsGenerating for chunk {} found, but manager state ({:?}) doesn't match NeedsGenerating({:?}). Assuming cancelled/stale.",
                    entity, coord, chunk_manager.get_state(coord.pos), entity
                );
                continue;
            }
        }

        debug!(
            target: "chunk_loading",
            "Starting generation task for {}.",
            coord
        );

        // spawn in the task with resources needed
        let (sender, receiver) = unbounded();

        let blocks_clone = block_registry.clone();
        let biomes_clone = biome_registry.clone();
        let terrain_gen = terrain_generator.clone();
        let biome_gen = biome_generator.clone();
        let climate_noise_clone = climate_noise.clone();
        let coord_clone = coord.clone();

        rayon::spawn(move || {
            let (biome_map, climate_map) = biome_gen
                .generate_biome_chunk(&coord_clone, &climate_noise_clone, &biomes_clone)
                .as_tuple();

            let tgen = terrain_gen.generate_terrain_chunk(
                coord_clone.pos,
                &biome_map,
                &climate_map,
                &blocks_clone,
                &biomes_clone,
            );

            trace!(
                target: "chunk_loading",
                "Finished generation for chunk {}.",
                coord_clone
            );

            let bundle = GeneratedChunkComponentBundle {
                chunk_blocks: tgen.chunk_blocks,
                biome_map: biome_map,
            };
            let _ = sender.send(bundle);
        });

        trace!(
            target: "chunk_loading",
            "Spawned generation task for chunk {}.",
            coord
        );

        commands
            .entity(entity)
            .insert(ChunkGenerationTaskComponent { receiver })
            .remove::<NeedsGenerating>();

        chunk_manager.mark_as_generating(coord.pos, entity);
    }
}

/// Polls chunk generation tasks, adds generated components, and marks chunks as
/// `NeedsMeshing` (if in range) or `DataReady` (if out of range).
#[instrument(skip_all)]
pub fn poll_chunk_generation_tasks(
    // Input
    mut tasks_query: Query<(Entity, &mut ChunkGenerationTaskComponent, &ChunkCoord)>,
    active_camera: Res<ActiveCamera>, // to gauge if chunk is in meshing range
    camera_query: Query<&ChunkCoord>,

    // Output
    mut commands: Commands,
    mut chunk_manager: ResMut<ChunkLoadingManager>,
) {
    let camera_chunk_pos = camera_query.get(active_camera.0).map(|c| c.pos);

    for (entity, generation_task_component, coord) in tasks_query.iter_mut() {
        // check for cancellation using the manager state
        match chunk_manager.get_state(coord.pos) {
            Some(ChunkState::Generating(gen_entity)) if gen_entity == entity => {
                // state is correct, proceed
            }
            _ => {
                debug!(
                    target : "chunk_loading",
                    "Chunk generation task for {} found but manager state is not Generating({:?}). Assuming cancelled.",
                    coord, entity
                );
                commands
                    .entity(entity)
                    .remove::<ChunkGenerationTaskComponent>();
                continue;
            }
        }

        // poll the generation task
        match generation_task_component.receiver.try_recv() {
            Ok(gen_bundle) => {
                if let Some(chunk_blocks) = gen_bundle.chunk_blocks {
                    let mut is_in_mesh_radius = false;
                    if let Ok(cam_pos) = camera_chunk_pos {
                        is_in_mesh_radius = chunk_is_in_mesh_radius(cam_pos, coord.pos);
                    }

                    if is_in_mesh_radius {
                        trace!(
                            target: "chunk_loading",
                            "Chunk generation finished for {}. In range. Marking as NeedsMeshing.",
                            coord
                        );
                        commands
                            .entity(entity)
                            .insert((
                                chunk_blocks,
                                gen_bundle.biome_map,
                                WantsMeshing,
                                CheckForMeshing,
                            ))
                            .remove::<ChunkGenerationTaskComponent>();
                        chunk_manager.mark_as_needs_meshing(coord.pos, entity);
                    } else {
                        trace!(
                            target: "chunk_loading",
                            "Chunk generation finished for {}. Out of range. Marking as DataReady.",
                            coord
                        );
                        commands
                            .entity(entity)
                            .insert((chunk_blocks, gen_bundle.biome_map))
                            .remove::<ChunkGenerationTaskComponent>();
                        chunk_manager.mark_as_data_ready(coord.pos, entity);
                    }
                } else {
                    trace!(
                        target: "chunk_loading",
                        "Chunk generation finished for {} but chunk is empty. Marking as Loaded(None).",
                        coord
                    );
                    commands.entity(entity).despawn();
                    chunk_manager.mark_as_loaded_but_empty(coord.pos);
                }

                // ping any neighbors that may have been waiting on this chunk
                for neighbor in chunk_manager.iter_neighbors(coord.pos) {
                    match neighbor.state {
                        ChunkState::NeedsMeshing(_) => {
                            commands.entity(neighbor.entity).insert(CheckForMeshing);
                        }
                        _ => {}
                    }
                }
            }
            Err(TryRecvError::Empty) => {
                // task still running
            }
            Err(TryRecvError::Disconnected) => {
                warn!(
                    target: "chunk_loading",
                    "Chunk generation task for {} failed (channel disconnected). Despawning entity.",
                    coord
                );
                commands.entity(entity).despawn();
                chunk_manager.mark_as_unloaded(coord.pos);
            }
        }
    }
}

/// Checks loaded chunks that have been signaled and frees their `ChunkBlocksComponent`
/// if and only if all 6 neighbors have also finished meshing (are Loaded or Empty).
#[instrument(skip_all)]
pub fn free_unneeded_chunk_data_system(
    // Input
    mut commands: Commands,
    chunk_manager: Res<ChunkLoadingManager>,

    // Chunks to check
    chunks_to_check_query: Query<
        (Entity, &ChunkCoord),
        (
            With<CheckForBlockDataIsNoLongerNeeded>,
            With<ChunkBlocksComponent>,
        ),
    >,
) {
    'chunk_loop: for (entity, coord) in chunks_to_check_query.iter() {
        commands
            .entity(entity)
            .remove::<CheckForBlockDataIsNoLongerNeeded>();

        for neighbor in chunk_manager.iter_neighbors(coord.pos) {
            match neighbor.state {
                ChunkState::Loaded(_) => {
                    continue;
                }
                // any neighbor not loaded means we cannot free the data yet
                _ => {
                    continue 'chunk_loop;
                }
            }
        }

        trace!(
            target: "chunk_loading",
            "All neighbors of {} are loaded. Freeing block data.",
            coord
        );

        commands
            .entity(entity)
            .remove::<ChunkBlocksComponent>()
            .remove::<ChunkCoord>();
    }
}
